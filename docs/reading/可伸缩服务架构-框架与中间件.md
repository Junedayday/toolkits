## 高性能的分布式发号器
- 分布式系统对发号器的基本需求
全局唯一，粗略有序，可反解，可制造，高性能，高可用，可伸缩

## 轻量级的数据库分库分表架构与框架
- 三个阶段
单库单表，单库多表，多库多表
- 三种方案
  1. 客户端分片
    - 应用层 实现简单，数据库连接数会很多，要做容量评估
    - 定制 JDBC
    - 定制 ORM
  2. 代理分片 在数据库和 JDBC 间实现，会增加一层网络传输，如 Cobar 和 Mycat
  3. 支持事务的分布式数据 如 OceanBase TiDB
- 切分方式
  1. 垂直切分
> `冷热分离` 冷数据查询多、变化少，适合MyISAM；热数据更新频繁，适合 InnoDB
  2. 水平切分
  两者都存在共同问题:
  - 分布式事物的问题
  - 跨节点 Join 的问题
  - 跨节点合并排序、分页的问题
  - 多数据源管理的问题

## 缓存的本质和缓存使用的优秀实践
- 适合缓存的场景
  - 读密集的应用
  - 存在热数据的应用
  - 对响应时效要求较高
  - 对一致性要求不严格
  - 需要实现分布式锁的时候
- 不适合使用缓存的场景
  - 读少
  - 更新频繁
  - 对一致性要求严格
- 分布式缓存分片的三种模式
  - 客户端分片 如 jar 包
  - 代理分片 如 codis 框架
  - 集群分片 如 Redis 3.0 提供的 Cluster
- 缓存设计的优秀实践
  - 评估内存消耗，包括缓存的数据结构、缓存大小、缓存数量、缓存的失效时间
  - 核心业务和非核心业务使用不同实例，物理上隔离
  - RDB 备份需要双倍的内存大小
  - 缓存超时不能过长，拖垮服务的线程池，建议 100ms
  - 实例监控，包括慢查询、大对象、内存使用情况
  - 不推荐多业务共享实例，如果不得不，须控制 key 的前缀
  - 所有的缓存必须设置失效时间，且不能集中于一个时间点
  - 低频访问数据不要放在缓存中
  - 单个缓存 key 的数据不宜过大
  - 对于存储较多 value 的 key，尽量不要使用 HGetAll 等集合操作
  - 缓存一般用于交易系统中加速查询的场景，有大量的更新数据时，尤其是批处理时，使用批量模式
  - 对性能要求不高，尽量用分布式缓存，因为本地缓存之间存在复制，某个时刻会不一致
  - 写缓存时，一定要保证数据正确、全部有效
  - 读: 缓存>数据库 写: 数据库>缓存
  - 使用缓存一定要有降级处理，有问题或者失效时，能回源到数据库处理
