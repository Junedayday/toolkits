## 有意义的命名：需要有良好的描述技巧
- 名副其实：变量、函数或类的名称
- 避免误导：避免隐藏代码本义的线索
- 做有意义的区分：例如a1，a2；data 与 info；去掉冗余字段
- 使用读得出来的名称
- 使用可搜索的名称：单字母名称只用于短方法中的本地变量，全局变量尽量详尽
- 避免思维映射：明确是王道
- 类名：应当为名词
- 方法名：动词或动词短语，如加上get，set，is前缀
- 每个概念对应一个词：controller/manager/driver
- 别用双关语：在保持一致性时，别将一个词语用在两个不同语境
- 使用解决方案领域名称
- 添加有意义的语境：例如给地址相关变量成员，增加 addr 前缀
- 不要添加没用的语境：只要短名称足够清楚，就比长名称好，如MACAddress，只需要MAC

## 函数
- 短小：函数最重要的特点，函数的缩进不要多余两层
- 只做一件事：函数只做一件事，做好这件事。看看能否再拆分出一个函数
- 每个函数一个抽象层级：自顶向下读代码，用 `// To XXX` 说明功能
- switch语句：无法实现短小，尽量放在抽象类下，不对外
- 使用描述性的名称：
  - 长而具有描述性的名称，比短而令人费解的号
  - 长而具有描述性的名称，比长注释好
  - 别害怕花时间取名字
  - 使用与模块名一脉相承的短语、名词和动词给函数命名
- 函数参数：
  - 尽量避免多参数，输出参数比输入参数更难理解
  - 多参数封装成有意义的对象
  - 参数与函数中的动词结合，加入方便理解的关键字
- 无副作用：只做一件事，函数名和实际功能一致
- 分割指令与询问：要么做什么事 setXXX，要么回答什么事 IfXXX
- 使用异常替代返回的错误码：抽离try...catch...到单独一个函数
- 别重复自己：一个算法在多个函数中重复，修改起来容易遗漏
- 结构化编程：每个代码块都应该有一个入口、一个出口，`goto`只在大函数里出现
---
**如何写出这样的函数**

先写出功能，配合单元测试，然后不断打磨：分解函数，修改名称，消除重复，最后组装。
---

## 注释：代码在变动，注释会撒谎，只有代码是真实的
- 注释不能美化糟糕的代码
- 用代码来阐述
- 好注释：
  - 法律信息：版权及著作权声明
  - 提供信息的注释：例如匹配格式为 XXX 的正则表达式
  - 对意图的解释：提供了某个决定背后的意图
  - 阐释：某些参数或者返回值晦涩难明，又因为是标准库或无法修改，进行阐释。阐释具有风险性，加倍小心其正确性。
  - 警示：警告会出现某些后果
  - TODO
  - 放大：放大某些看过去不合理之物的重要性
  - 公共API的doc
- 坏注释；
  - 喃喃自语
  - 多余的注释：不如代码直白明确
  - 误导性注释：不够精确
  - 循规式注释：没必要全部按照javadoc
  - 日志式注释：修改记录
  - 代码注释：直接释放
  - 信息过多：长篇内容应该用链接或者专门的文档
  - 不明显的联系：注释本身不易理解或与代码相关性很低

## 格式
- 垂直格式：
  - 概念垂直方向：概念相近的靠近
  - 变量声明尽量靠近其使用位置（短函数）
  - 相关函数：尽量靠近，调用者尽量在被调用者上面
- 横向格式：
  - 水平方向上不要太长
  - 水平对齐（自动对齐工具）

## 对象和数据结构
- 数据抽象：不暴露数据，隐藏其实现，提供抽象接口
- 数据、对象的反对称性：根据场景自行选择
  - 面向过程（暴露数据，容易修改）
  - 面向对象（提供接口，修改麻烦）
- The Law of Demeter
  - 火车失事：连锁反应，如a.F1().F2()
  - 混杂：对象和数据混乱

## 错误处理
- 使用异常而非返回码：try-catch-finally
> golang 官方不推荐统一处理异常，[点击链接](https://blog.golang.org/error-handling-and-go)

## 边界
- 整洁的边界：与第三方库，包括内部的模块

## 单元测试
- 保持测试整洁：测试代码和生产代码一样重要
- 整洁的测试：可读性第一
  - 可以选择适当的测试语言、测试库
  - 可以适当牺牲性能
- 每个测试一个断言（每个测试一个概念）
- FIRST:fast,independent,repeatable,self-Validating,Timely

## 类
- 类的组织：封装使之保有隐私
- 类应该短小：
  - 单一权责原则：类或者模块应有且只有一条加以修改的理由。
  - 内聚：类应该只有少量实体变量，方法操作的变量越多，就越黏聚到类上。
  - 保持内聚性就会得到许多短小的类
- 为了修改而组织：预见未来的修改，提前组织好类的结构，符合单一权责原则

## 系统
- 将系统的构造与使用分开：
  - 分解main：将全部构造过程搬迁到main或者main的相关模块中
- 扩容：

## 迭进：简单设计的四条规则
- 运行所有测试：测试消除了对清理代码就会破坏代码的恐惧
- 不可重复
- 表达力
- 尽可能少的类和方法
> 这四条按优先级从高到低排序

## 并发编程

## 逐步改进：保持代码持续整洁和简单，没有机会腐坏

## 味道与启发
- 注释：不恰当的信息，废弃的注释，冗余注释，糟糕的注释，注释的代码
- 环境：需要多少步才能实现构建、测试
- 函数：过多的参数，输出参数，标示参数（如bool），死函数（永不调用）
- 一般性问题：
  - 一个源文件存在多种语言
  - 明显的行为未被实现
  - 不正确的边界行为
  - 忽视安全
  - 重复在错误的抽象层级上的代码，
  - 基类依赖于派生类
  - 信息过多
  - 死代码
  - 垂直分隔
  - 前后不一致
  - 混淆视听
  - 人为耦合
  - 特性依赖
  - 选择算子参数
  - 晦涩的意图
  - 位置错误的权责
  - 不恰当的静态方法（如`a.max(b)`应该被替换为`max(a,b)`）
  - 使用解释性变量（如key,value应该加上具体含义）
  - 函数名称应该表达其行为
  - 理解算法
  - 把逻辑依赖改为物理依赖：把某种变量的依赖，具象为一个方法
  - 用多态替代 if/else 或 switch/case：每个 switch 的类型用一个类封装
  - 遵循标准约定
  - 用命名常量替代魔术数
  - 准确
  - 结构甚于决定
  - 封装条件
  - 避免否定性条件
  - 函数只做一件事
  - 掩蔽时序性耦合
  - 别随意
  - 封装边界条件
  - 函数应该只在一个抽象层级上
  - 在较高层级放置可配置数据